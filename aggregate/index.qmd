---
title: Agr√©ger des donn√©es
format:
  lille-univ-revealjs: default
author: Arthur Br√©ant
---

# Agr√©ger des donn√©es

## Les fonctions 

Il existe en SQL des **fonctions** qui permettent de r√©aliser des **op√©rations de calculs**, de **modifier des cha√Ænes de caract√®res** ou encore de **manipuler des dates**.

Nous retrouvons les principales fonctions : 

**d'aggr√©gations** :  
<font color="#188630">`MAX`</font> = maximum ; 
<font color="#188630">`MIN`</font> = minimum ; 
<font color="#188630">`SUM`</font> = somme ;  
<font color="#188630">`COUNT`</font> = d√©nombrement ; 
<font color="#188630">`AVG`</font> = moyenne

\  
 
**de modifications de texte** :  
<font color="#188630">`UPPER`</font> = majuscule ; 
<font color="#188630">`LOWER`</font> = minuscule ;  
<font color="#188630">`SUBSTR`</font> = tronque ; 
<font color="#188630">`LENGTH`</font> = compte 

# Op√©rations textuelles

## Modifier du texte 

Quelques exemples avec les fonctions qui modifient du texte :

Mettons le nom des joueurs en majuscules !

```{r}
#| echo: true
#| eval: false
dbGetQuery(
  conn = db,
  "SELECT UPPER(name)
  FROM players"
)
```

A l'inverse, mettons les noms des clubs en minuscules :

```{r}
#| echo: true
#| eval: false
dbGetQuery(
  conn = db,
  "SELECT LOWER(club)
  FROM players"
)
```

## La fonction substr

La fonction <font color="#188630">`substr`</font> permet de tronquer une partie d'une cha√Æne de caract√®re.

```{sql, eval=FALSE, echo=TRUE}
SELECT SUBSTR(colonne, start, length)  
FROM tableau
```

Afficher les initiales (deux premi√®res lettres) des √©quipes nationales, sans les doublons:

```{r}
#| echo: true
#| eval: false
dbGetQuery(
  conn = db,
  "?"
)
```

::: {.fragment .fade-in}
Afficher les initiales

```{r}
#| echo: true
#| eval: false
dbGetQuery(
  conn = db, 
  "SELECT DISTINCT SUBSTR(team, 1, 2) AS initiales, team 
  FROM players"
)
```
:::

# Op√©rations statistiques

## Les fonctions d'aggr√©gation

En SQL, les fonctions d'aggr√©gation sont tr√®s utiles et tr√®s souvent utilis√©es. Elles permettent de r√©aliser des **premi√®res op√©rations statistiques** sur une base de donn√©es. Les fonctions d'aggr√©gation s'appliquent aux colonnes de nos tables : 

```{sql, eval=FALSE, echo=TRUE}
SELECT fonction(colonne)  
FROM tableau
```

Pour compter le nombre d'observations dans notre table, on peut utiliser la requ√™te :

```{r}
#| echo: true
#| eval: false
dbGetQuery(
  conn = db, 
  "SELECT COUNT(*) AS total 
  FROM players")
```

Calculons quelques donn√©es...

## Les fonctions d'aggr√©gation 

Quel est le nombre de s√©lections total ? 

```{r}
#| echo: true
#| eval: false
dbGetQuery(
  conn = db, 
  "?"
)
```

Quel est le nombre de s√©lections moyen ? 

```{r}
#| echo: true
#| eval: false
dbGetQuery(
  conn = db, 
  "?"
)
```

Quel est le nombre de milieu de terrain ?  

```{r}
#| echo: true
#| eval: false
dbGetQuery(
  conn = db, 
  "?"
)
```

Quel est le nombre de s√©lections moyen des capitaines ? 

```{r}
#| echo: true
#| eval: false
dbGetQuery(
  conn = db, 
  "?"
)
```

## Les fonctions d'aggr√©gation 

::: {.fragment .fade-in-then-semi-out}
Le nombre de s√©lections total : 

```{r}
#| echo: true
#| eval: false
dbGetQuery(
  conn = db, 
  "SELECT SUM(played) AS sum_played
  FROM players"
)
```
:::

::: {.fragment .fade-in-then-semi-out}
Le nombre de s√©lections moyen : 

```{r}
#| echo: true
#| eval: false
dbGetQuery(
  conn = db, 
  "SELECT AVG(played) AS mean_played 
  FROM players"
)
```
:::

::: {.fragment .fade-in-then-semi-out}
Le nombre de milieu de terrain :  

```{r}
#| echo: true
#| eval: false
dbGetQuery(
  conn = db, 
  "SELECT COUNT(position) 
  FROM players 
  WHERE position = 'Milieu'"
)
```
:::

::: {.fragment .fade-in-then-semi-out}
Le nombre de s√©lections moyen des capitaines :

```{r}
#| echo: true
#| eval: false
dbGetQuery(
  conn = db, 
  "SELECT AVG(played) AS captain_mean 
  FROM players 
  WHERE captain = 1"
)
```
:::

# GROUP BY

## Regrouper ses observations

Pour utiliser pleinement la puissance des fonctions d'aggr√©gation, on utilise la commande <font color="#188630">`GROUP BY`</font>.

Cette instruction permet de regrouper nos **observations identiques** et d'appliquer la fonction d'aggr√©ation sur ces groupes.

```{sql, eval=FALSE, echo=TRUE}
SELECT colonne, fonction(colonne)  
FROM tableau
GROUP BY colonne
```

## GROUP BY 

Quel est le nombre de joueurs par position ?  

```{r}
#| echo: true
#| eval: false
dbGetQuery(
  conn = db, 
  "?"
)
```

Combien y-a-t-il de joueurs par √©quipe ? 

```{r}
#| echo: true
#| eval: false
dbGetQuery(
  conn = db, 
  "?"
)
```


Quel est le nombre de s√©lection moyen des capitaines et des non capitaines ? Trier par ordre d√©croissant de s√©lections

```{r}
#| echo: true
#| eval: false
dbGetQuery(
  conn = db, 
  "?"
)
```

## GROUP BY 

::: {.fragment .fade-in-then-semi-out}
Le nombre de joueurs par position : 

```{r}
#| echo: true
#| eval: false
dbGetQuery(
  conn = db, 
  "SELECT position, COUNT(*) 
  FROM players 
  GROUP BY position"
)
```
:::

::: {.fragment .fade-in-then-semi-out}
Le nombre de joueurs par √©quipe :

```{r}
#| echo: true
#| eval: false
dbGetQuery(
  conn = db, 
  "SELECT team, COUNT(*) 
  FROM players 
  GROUP BY team"
)
```
:::

::: {.fragment .fade-in-then-semi-out}
Le nombre de s√©lection moyen des capitaines et non capitaine, trier par ordre d√©croissant :

```{r}
#| echo: true
#| eval: false
dbGetQuery(
  conn = db, 
  "SELECT captain, AVG(played) AS avg_played 
  FROM players
  GROUP BY captain
  ORDER BY avg_played DESC"
)
```
:::

# Exercice interm√©diaire

Mettons nos connaissances en pratique ! 

Parmi les clubs suivants :   
\ 
_Real Madrid, Barcelona, Arsenal, Chelsea, Liverpool, Juventus_  
\ 

Quel est le club qui a le plus de joueurs qui ont particip√© √† la Coupe du Monde ?
Calculer √©galement le nombre de s√©lections moyen des joueurs appartenant √† ces clubs.
Trier du plus grand effectif au plus petit effectif.

```{r}
#| echo: true
#| eval: false
dbGetQuery(
  conn = db, 
  "?"
)
```

## Exercice interm√©diaire

Correction : 

```{r}
#| echo: true
#| eval: false
dbGetQuery(
  conn = db,
  "SELECT club, COUNT(*) AS effectif, 
          AVG(played) AS 'Moyenne played'
  FROM players
  WHERE club IN ('Real Madrid', 'Barcelona', 'Arsenal', 
                 'Chelsea', 'Liverpool', 'Juventus')
  GROUP BY club
  ORDER BY effectif DESC"
)
```

# HAVING

## La clause HAVING

Imaginons que nous souhaitions filtrer les clubs qui avaient au moins 12 joueurs repr√©sent√©s √† la Coupe du Monde. En SQL, c'est possible gr√¢ce √† la condition <font color="#188630">`HAVING`</font> !

L'instruction <font color="#188630">`HAVING`</font> est similaire √† l'instruction <font color="#188630">`WHERE`</font>, √† ceci pr√®s que <font color="#188630">`HAVING`</font> permet d'appliquer un filtre **sur les fonctions d'aggr√©gation**. 

_<small><font color="#848484">`L'instruction WHERE ne s'applique pas aux fonctions d'aggr√©gation !`</font></small>_

_<small><font color="#848484">`Les alias ne peuvent pas -toujours- √™tre utilis√©s dans la condition HAVING`</font></small>_

```{sql, eval=FALSE, echo=TRUE}
SELECT colonne_1, fonction(colonne_2) AS alias
FROM tableau
GROUP BY colonne_1
HAVING fonction(colonne_2) operateur valeur
```

## La clause HAVING

Plus concr√®tement ? ü§®

Reprenons notre exercice pr√©c√©dent. Conservons les clubs avec au moins 12 joueurs repr√©sent√©s.

```{r}
#| echo: true
#| eval: false
dbGetQuery(
  conn = db, 
  "SELECT club, COUNT(*) AS effectif, AVG(played) AS 'Moyenne played'
  FROM players
  WHERE club IN ('Real Madrid', 'Barcelona', 'Arsenal', 
                 'Chelsea', 'Liverpool', 'Juventus')
  GROUP BY club
  HAVING effectif >= 12
  ORDER BY effectif DESC"
)
```

## La clause HAVING

<small><font color="#848484">`Un pi√®ge est gliss√© dans une des questions suivantes üòâ`</font></small> 
 
1/ Quel est le nombre de joueurs par position ? Filtrer les positions ayant plus de 100 joueurs

```{r}
#| echo: true
#| eval: false
dbGetQuery(
  conn = db, 
  "?"
)
```


2/ Qui est le milieu de terrain n√© entre 1994-01-01 et 1994-03-31 et qui poss√®de plus de 3 s√©lections ?

```{r}
#| echo: true
#| eval: false
dbGetQuery(
  conn = db, 
  "?"
)
```

3/ Quels sont les clubs ayant uniquement 1 joueur repr√©sent√© √† cette comp√©tition et dont le nom du club commence par un "S" ?

```{r}
#| echo: true
#| eval: false
dbGetQuery(
  conn = db, 
  "?"
)
```

## La clause HAVING

::: {.fragment .fade-in-then-semi-out}
```{r}
#| echo: true
#| eval: false
dbGetQuery(
  conn = db, 
  "SELECT position, COUNT(*) AS total
  FROM players 
  GROUP BY position 
  HAVING total > 100"
)
```
:::

::: {.fragment .fade-in-then-semi-out}
```{r}
#| echo: true
#| eval: false
dbGetQuery(
  conn = db, 
  "SELECT name, position, birth_date
  FROM players
  WHERE position = 'Milieu' 
    AND birth_date BETWEEN '1994-01-01' AND '1994-03-31'
    AND played > 3"
)
```
:::

::: {.fragment .fade-in-then-semi-out}
```{r}
#| echo: true
#| eval: false
dbGetQuery(
  conn = db, 
  "SELECT club, COUNT(*) AS effectif 
  FROM players 
  WHERE club LIKE 'S%'
  GROUP BY club 
  HAVING effectif = 1"
)
```
:::

# CASE ... WHEN

## CASE ... WHEN

En SQL, l'expression <font color="#188630">`CASE WHEN`</font> permet de r√©aliser une condition de type : <font color="#c7254e">`SI ... SINON`</font>. 

Cette op√©ration permet notamment de **cr√©er une nouvelle variable (colonne)**. Elle s'utilise **avec les op√©rateurs de comparaisons**.

```{sql, eval=FALSE, echo=TRUE}
SELECT CASE 
  WHEN colonne op√©rateur condition THEN "valeur 1"
  WHEN colonne op√©rateur condition THEN "valeur 2"
  ..
  ELSE "valeur"
  END AS alias
FROM tableau
```

_<small><font color="#848484">`A noter, la condition ELSE n'est pas obligatoire !`</font></small>_

Vite, vite un exemple !

## CASE ... WHEN

Recodons la colonne <font color="#c7254e">`captain`</font> de notre table <font color="#c7254e">`players`</font>. Plut√¥t que des 0 et des 1, nous souhaitons avoir les valeurs suivantes : <font color="#c7254e">`capitaine`</font> ou <font color="#c7254e">`non capitaine`</font>.

```{r}
#| echo: true
#| eval: false
dbGetQuery(
  conn = db, 
  "SELECT *, 
          CASE 
            WHEN captain = 1 THEN 'capitaine' 
            WHEN captain = 0 THEN 'pas capitaine' 
          END AS captain2 
  FROM players"
)
```
 
On peut aussi √©crire :

```{r}
#| echo: true
#| eval: false
dbGetQuery(
  conn = db, 
  "SELECT *, 
          CASE 
            WHEN captain = 1 THEN 'capitain' 
            ELSE 'pas capitaine' 
          END AS captain2 
  FROM players"
)
```

## CASE ... WHEN

Cr√©er une colonne nomm√©e <font color="#c7254e">`experience`</font> qui contient : `joueur exp√©riment√©` si le joueur a plus de 40 s√©lections ; `joueur confirm√©` si le joueur a entre 20 et 40 s√©lections ; `jeune joueur` si le joueur a moins de 20 s√©lections. 

```{r}
#| echo: true
#| eval: false
dbGetQuery(
  conn = db, 
  "?"
)
```

Cr√©er une colonne nomm√©e <font color="#c7254e">`captain_exp`</font> qui contient : `capitaine exp√©riment√©` si le joueur est capitaine avec 40 ou + s√©lections ; `jeune capitaine` si le joueur est capitaine avec moins de 40 s√©lections. Idem avec les non capitaines : `jeune joueur` et `joueur exp√©riment√©`

```{r}
#| echo: true
#| eval: false
dbGetQuery(
  conn = db, 
  "?"
)
```

## CASE ... WHEN 

::: {.fragment .fade-in-then-semi-out}
```{r}
#| echo: true
#| eval: false
dbGetQuery(
  conn = db, 
  "SELECT *, 
          CASE 
            WHEN played > 40 THEN 'joueur exp√©riment√©'
            WHEN played BETWEEN 20 AND 40 THEN 'joueur confirm√©'
            ELSE 'jeune joueur' 
          END AS experience
  FROM players
  ORDER BY played"
)
```
:::

::: {.fragment .fade-in-then-semi-out}
```{r}
#| echo: true
#| eval: false
dbGetQuery(
  conn = db,
  "SELECT *, 
          CASE 
            WHEN played >= 40 AND captain = 1 THEN 'capitaine exp√©riment√©'
            WHEN played < 40 AND captain = 1 THEN 'jeune capitaine'
            WHEN played >= 40 AND captain = 0 THEN 'joueur exp√©riment√©'
            WHEN played < 40 AND captain = 0 THEN 'jeune joueur' 
          END AS captain_exp
  FROM players
  ORDER BY played"
)
```
:::

## Exercice r√©capitulatif

Cr√©er une colonne <font color="#c7254e">`continent`</font> qui regroupe les continents : 

_<small>`Europe` : Croatie, Espagne, Pays-Bas, Grece, Angleterre, Italie, France, Suisse, Bosnie-Herzegovine, Allemagne, Portugal, Belgique </small>_

_<small>`Afrique` : Cameroun, Cote d'Ivoire, Nigeria, Ghana, Algerie </small>_

_<small>`Am√©rique` : Br√©sil, Mexique, Chili, Colombie, Costa Rica, Uruguay, Equateur, Honduras, Argentine, Etats-Unis</small>_

_<small>`Asie` : Japon, Iran, Coree du Sud, Russie</small>_

_<small>`Oc√©anie` : Australie</small>_

Puis, pour chacun des continents, compter le nombre de joueurs et de s√©lections totales. Trier du continent avec le plus de s√©lections √† celui avec le moins. Exclure les continents avec moins de 1200 s√©lections.

## Exercice r√©capitulatif

```{r}
#| echo: true
#| eval: false
dbGetQuery(
  conn = db, 
  "SELECT CASE 
        WHEN team IN ('Cameroun', 'Cote d''Ivoire', 'Nigeria', 
                     'Ghana', 'Algerie') THEN 'Afrique'
        WHEN team = 'Australie' THEN 'Oc√©anie'
        WHEN team IN ('Br√©sil', 'Mexique', 'Chili', 'Colombie', 
                     'Costa Rica', 'Uruguay', 'Equateur', 
                     'Honduras', 'Argentine', 
                     'Etats-Unis') THEN 'Am√©rique'
        WHEN team IN ('Japon', 'Iran', 'Coree du Sud', 
                     'Russie') THEN 'Asie'
        ELSE 'Europe'
        END AS continent, COUNT(*) AS n_joueurs, SUM(played) AS sum_selec
  FROM players
  GROUP BY continent
  HAVING SUM(played) > 1200
  ORDER BY sum_selec DESC"
)
```

## Synth√®se 

```{sql, eval=FALSE, echo=TRUE}
SELECT [ DISTINCT ] : S√©lectionne des variables [Affiche sans doublons]
FROM     : Pr√©cise le tableau dans laquelle se trouve les donn√©es
WHERE    : Filtre les donn√©es selon une ou plusieurs conditions
GROUP BY : Regroupe les modalit√©s d''une variable
HAVING   : Ajoute un filtre sur une fonction d''aggr√©gation
ORDER BY : Ordonne une ou plusieurs colonnes
```

## Continuons !

La suite : [Agr√©ger des donn√©es, la suite !]()

